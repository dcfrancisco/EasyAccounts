#include "std.ch"

/*
Financial Status by Period
**************************
A Comprehensive and Exhausting Report to analyze
the ups & downs of each month. Combining inventory & accounts,
the main challenge is to consolidate all these within the given period
and to present the summary in a monthly table.

Developed by : Jasim A Basheer
For EasyAccounts v1.5 MIS Module
*/

#include "inkey.ch"
static dFrom
static dTo
static aStatus
//=====================================
function finperiod

local actF
local actTo
local nAddDays
local debtor
local creditor
local bank
local stock
local franchis
local xx
local nS
local nE
local nC
local nLine    := 0
local n1
local nY1      := year( date() ) - 1
local nY2      := year( date() )

aStatus := {}
xx      := makebox( 8, 02, 12, 30 )
@ 09, 03 say "From : "         
nS := popmonth()
@ 09, 03 say "From : " + cmonth( ctod( '01/' + str( nS, 2, 0 ) + '/2002' ) )                                      
@ 09, 22 get nY1                                                             pict '9999' valid ( nY1 != 0 )       
read
@ 10, 03 say "  To : "         
nE := popmonth()
@ 10, 03 say "  To : " + cmonth( ctod( '01/' + str( nE, 2, 0 ) + '/2002' ) )         
nY2 := nY1
@ 10, 22 get nY2 pict '9999' valid ( nY2 != 0 )       
read

dFrom := ctod( '01/' + str( nS ) + '/' + str( nY1 ) )
dTo   := ctod( str( daysin( ctod( '01/' + str( nS ) + '/' + str( nY1 ) ) ), 2, 0 ) + "/" + str( nS ) + '/' + str( nY1 ) )
nC    := 1
do while .t.
   plswait( .t., 'Summing up values..' + cmonth( dTo ) )
   // Yar know? I am a great fool. But i dont think so. I just am a lazy idiot.

   if dFrom > dTo
      plswait( .f. )
      msg( "Invalid Period!" )
      unbox( xx )
      return .f.
   endif

   debtor   := 0.00
   creditor := 0.00
   bank     := 0.00
   stock    := 0.00

   Debtor   := prd_tot( 1 )
   Debtor   += prd_tot( 4 )             // staff loan
   Creditor := prd_tot( 2 ) * - 1
   Bank     := prd_tot( 3 )
   Stock    := mas_tot()
   Franchis := prd_tot( 5 )

   aadd( aStatus, { subs( cmonth( dTo ), 1, 3 ) + " " + subs( str( year( dTo ), 4, 0 ), 3 ), debtor, creditor, bank, stock, franchis, debtor + bank + stock - creditor + franchis } )

   close all
   dTo += daysin( dTo + 5 )             // to find out for the next month.
   //dateCalc(dTo,1,3) // Adds one month each.
   nC ++
   plswait( .f. )
   if inkey() == K_ESC
      if jAlert( 'ABORT OPERATION ?', { 'Yes', 'No' } ) = 1
         close all
         return nil
      endif
   endif
   if dTo > ctod( str( daysin( ctod( '01/' + str( nE, 2, 0 ) + '/' + str( nY2, 4, 0 ) ) ), 2, 0 ) + ;
              '/' + str( nE, 2, 0 ) + '/' + str( nY2, 4, 0 ) )
      exit
   endif
enddo

close all
plswait( .t., 'Generating Report...' )

set printer to (RepPath+'FINPRD.TXT')
set device to printer
set printer on

@ nLine,  0 say padc( gPrefix + iif( !empty( gPrefix ), ', ', '' ) + comp_add, 18 + ( ( len( aStatus ) ) * 10 ) )         
nLine ++
@ nLine,  0 say padc( 'MIS System - Financial Analysis', 18 + ( ( len( aStatus ) ) * 10 ) )         
nLine ++
@ nLine,  0 say padc( '        ** generated by EA v1.5', 18 + ( ( len( aStatus ) ) * 10 ) )         
nLine ++
@ nLine,  0 say repli( '-', 18 + ( ( len( aStatus ) ) * 10 ) )         
nLine ++
@ nLine,  0 say "Particulars"         

for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say padl( aStatus[ xx, 1 ], 8 )         
next xx
nLine ++
@ nLine,  0 say repli( '-', 18 + ( len( aStatus ) ) * 10 )         
nLine ++
n1 := 0.00
@ nLine,  0 say "Stock at Hand"         

for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say str( aStatus[ xx, 5 ], 8, 0 )         
next xx

nLine ++
n1 := 0.00
@ nLine,  0 say "Debtors"         
for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say str( aStatus[ xx, 2 ], 8, 0 )         
next xx
nLine ++
@ nLine,  0 say "Bank"         
n1 := 0.00
for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say str( aStatus[ xx, 4 ], 8, 0 )         
next xx
nLine ++

n1 := 0.00
@ nLine,  0 say "Creditors"         
for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say str( aStatus[ xx, 3 ] * - 1, 8, 0 )         
next xx
nLine ++
n1 := 0.00

@ nLine,  0 say "Associates"         
for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say str( aStatus[ xx, 5 ], 8, 0 )         
next xx
nLine ++

n1 := 0.00
for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say repli( '-', 8 )         
next xx
nLine ++
n1 := 0.00
@ nLine,  0 say "BALANCE"         
for xx := 1 to len( aStatus )
   @ nLine, 18 + ( ( xx - 1 ) * 10 ) say str( aStatus[ xx, 6 ], 8, 0 )         
next xx
nLine ++
nLine ++
nLine ++
@ nLine,  0 say " "         
set devic to screen
set printer off
set printer to
set console on
close all
plswait( .f. )
dispscrn()
fileread( 4, 05, 20, 73, RepPath+'FINPRD.TXT', 'Monthly Financial Analysis' )

erase FINPRD.TXT // Highly official record. Not to be public at
// any cost.
return nil
//--------------
/*
static function prd_tot(nList)
local nTot := 0.00
use accounts new index ACC_1
use cashbook new index CSH_1,CSH_2,CSH_3,CSH_4,CSH_5
set order to 5
use daybook  new index DBK_1,DBK_2,DBK_3,DBK_4,DBK_5
set order to 4
use bankbook new index BNK_1,BNK_2,BNK_3,BNK_5,BNK_6
if nList=3
   set order to 5
else
   set order to 4
endif
sele accounts
nDTotal := 0.00
do while .not. eof()
   if ( nList=1 .and. ( rtrim(ltrim(type)) = 'Debtor' ) .or. rtrim(ltrim(type)) = 'Staff Loan' ) ;
      .or. ( nList=2 .and. rtrim(ltrim(type)) = 'Sundry Creditor' ) ;
      .or. ( nList=3 .and. rtrim(ltrim(type)) = 'Bank' ) ;
      .or. ( nList=5 .and. rtrim(ltrim(type)) = 'Expense' )

      nD := opbal        // that may be negative if is in the credit column.
      nC := 0.00         // so, same THING, same EFFECT, same WOrds...!

      select cashbook
      seek accounts->id
      if found()
         do while account == accounts->id
           if date >= dFrom .and. date <= dTo
            if action='D'
               nD += amount
            elseif action='C'
               nC += amount
            endif
           endif
            skip
         enddo
      endif

      if nList=3
         select bankbook
         seek accounts->id
         if found()
            do while b_id == accounts->id
              if date >= dFrom .and. date <= dTo
               if action='C'
                  nD += amount
               elseif action='D'
                  nC += amount
               endif
              endif
               skip
            enddo
         endif
      else
         select bankbook
         seek   accounts->id
         if found()
            do while account == accounts->id
              if date >= dFrom .and. date <= dTo
               if action='D'
                  nD += amount
               elseif action='C'
                  nC += amount
               endif
              endif
              skip
            enddo
         endif
      endif

      select daybook
      seek accounts->id
      if found()
         do while account == accounts->id
           if date >= dFrom .and. date <= dTo
            if action='D'
               nD += amount
            elseif action='C'
               nC += amount
            endif
           endif
            skip
         enddo
      endif
      nTot += (nD-nC)
   endif

   sele accounts
   skip
enddo
close all
return nTot
*/
//=====================================================
function mas_tot

local nStock := 0.00

close all
use saccount new index SAC_1,SAC_2,SAC_3
set order to 1 // Doc.No
use paccount new index PAC_1,PAC_2,PAC_3
set order to 1 // Doc.No
use master new index MAS_1,MAS_2
set order to 1
use sales new index SALE_1,SALE_2
set order to 2 // Item_ID
use purchase new index PRCH_1,PRCH_2
set order to 2 // Item_ID
sele master

do while .not. eof()
   nStock += begin * cost
   sele sales
   seek master->id
   if found()
      do while master->id == sales->item_id .and. ( !eof() )
         sele saccount
         seek sales->id
         if date >= dFrom .and. date <= dTo
            nStock -= sales->qty * sales->cost
         endif
         sele sales
         skip
      enddo
   endif
   sele purchase
   seek master->id
   if found()
      do while master->id == purchase->item_id .and. ( !eof() )
         sele paccount
         seek purchase->id
         if date >= dFrom .and. date <= dTo
            nStock += purchase->qty * purchase->cost
         endif
         sele purchase
         skip
      enddo
   endif
   sele master
   skip
enddo
close all
return nStock
//=================================
function prd_tot( nList )

local nJasTot := 0.00
use accounts new index ACC_1
use cashbook new index CSH_1,CSH_2,CSH_3,CSH_4,CSH_5
set order to 5
use daybook new index DBK_1,DBK_2,DBK_3,DBK_4,DBK_5
set order to 4
use bankbook new index BNK_1,BNK_2,BNK_3,BNK_5,BNK_6
if nList = 3
   set order to 5
else
   set order to 4
endif

sele accounts
nDTotal := 0.00
do while .not. eof()
   if ( nList = 1 .and. rtrim( ltrim( type ) ) = 'Debtor' ) .or. ( nList = 1 .and. ;
        rtrim( ltrim( type ) ) = 'Staff Loan' ) ;
        .or. ( nList = 2 .and. rtrim( ltrim( type ) ) = 'Sundry Creditor' ) ;
        .or. ( nList = 3 .and. rtrim( ltrim( type ) ) = 'Bank' ) ;
        .or. ( nList = 5 .and. rtrim( ltrim( type ) ) = 'Associate' )

      nD := opbal   // that may be negative if is in the credit column.
      nC := 0.00    // so, same THING, same EFFECT, same WOrds...!

      select cashbook
      seek accounts->id
      if found()
         do while account == accounts->id
            if inPeriod()
               if action = 'D'
                  nD += amount
               elseif action = 'C'
                  nC += amount
               endif
            endif
            skip
         enddo
      endif

      if nList = 3
         select bankbook
         seek accounts->id
         if found()
            do while b_id == accounts->id
               if inPeriod()
                  if action = 'C'
                     nD += amount
                  elseif action = 'D'
                     nC += amount
                  endif
               endif
               skip
            enddo
         endif
      else
         select bankbook
         seek accounts->id
         if found()
            do while account == accounts->id
               if inPeriod()
                  if action = 'D'
                     nD += amount
                  elseif action = 'C'
                     nC += amount
                  endif
               endif
               skip
            enddo
         endif
      endif

      select daybook
      seek accounts->id
      if found()
         do while account == accounts->id
            if inPeriod()
               if action = 'D'
                  nD += amount
               elseif action = 'C'
                  nC += amount
               endif
            endif
            skip
         enddo
      endif

      if nD - nC != 0
         nJasTot += ( nD - nC )
      endif
   endif

   sele accounts
   skip
enddo
close all
return nJasTot
//=============================
function inPeriod

return date >= dFrom .and. date <= dTo

*+ EOF: FIN_PRD.PRG
